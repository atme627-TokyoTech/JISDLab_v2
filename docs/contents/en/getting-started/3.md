## 3. Debugging with ProbeJ
ProbeJ is a tool to observe a running program. It uses JVMTI internally, and can be used by specifying it as an agent when starting the JVM. The following is an example of executing a Java program with ProbeJ.

```bash
java -agentpath:lib/ProbeJ_ex.dll=options_none:39876 -cp bin jisd.demo.LoopN
```

ProbeJ has the following features.
- It collects only the information specified by the user.
- It is possible to set and clear breakpoints and get observation results during the observation.
- Minimizes the impact on the program execution.
- Observation is performed while the program execution is continued (with only a short stop).

The biggest advantage of using ProbeJ is that it minimizes the impact on the program execution.
In addition, ProbeJ is suitable for debugging a running program because the observation is performed while the program is still running.

Currently, ProbeJ is available only on Windows, and it is not possible to run ProbeJ on other operating systems.  
On the other hand, it is possible to debug a program started with ProbeJ on Windows from the same host or from other OS.

In section 3, we will explain debugging using ProbeJ.

### 3.1 Starting and Stopping the Debugger

In debugging using ProbeJ, when the debugger is started, the target program is started with ProbeJ added if necessary, and then the communication with ProbeJ is started. **When the target program with ProbeJ is launched internally**, the main thread of JISD always waits for 1 second** before launching the target program and starting communication. Of the 1 second, 0.8 seconds is set in advance as the start-up wait time of the target program. If the target program with ProbeJ attached is running externally, it does not wait and communication starts immediately.

The Debugger is generated as follows.


```java
var dbg = new Debugger("jisd.demo.HelloWorld", "-cp ../sample", true) // Windows only
```

Alternatively, you can use


```java
var dbg = new Debugger("host.docker.internal", 39876, true) // Host: Windows only, Container: Windows or Linux
```

The following code will start the debugger.


```java
dbg.run(1000)
```

The argument of run() is the approximate time in milliseconds until the target program reaches the observation point. In the above case, the main thread will be restarted after (1 second waiting time to start communication with ProbeJ) + (1 second specified by the user) = 2 seconds from the start of run().

To exit debugging, execute the following.


```java
dbg.exit()
```

Note that when you exit debugging, the communication with ProbeJ will be stopped, but the target program will not be terminated.


### 3.2 Setting Observation Points
In debugging with ProbeJ of JISD, one type of observation point, **Pulve Point**, is provided.

When the **Pulve Point** is set, only the value of the variable is observed when the observation point is reached, and the maximum number of 100 is retained by ProbeJ.

In debugging using ProbeJ, it is necessary to specify for which variable the observation point is set.

The specific setting method is described below.

### 3.3 Setting ProbePoint

If you want to set a probe point to `variable a` and `variable b` in `line 20` of the `jisd.demo.Sub` for the debugger instance `dbg` created in 3.1, you can set them as follows.


```java
String[] vars = {"a", "b"};
Optional<Point> pp = dbg.watch("jisd.demo.HelloWorld", 20, vars);
```

A pull point is treated as an instance of the ProbePoint class, which inherits from the Point class. A pull point is treated as an instance of the ProbePoint class, which inherits from the Point class, and a line cannot have more than one observation point.

Unlike breakpoints and watchpoints, pull points do not generate a DebugResult object until getResults() is called, and ProbeJ holds up to 100 observation values until getResults() is called.

As with debugging using JPDA, default class names can be used. (â†’2.5)

