## 2. JPDAを用いたデバッグ
JPDAとはJava Platform Debugger Architectureの略で，Javaプログラムのデバッグを行うための枠組みです．  
JPDAは以下の3つから構成されます．
- JVMTI(Java VM Tool Interface)
  - 実行中のJavaプログラムの内部状態観測・実行制御を行うインタフェース
- JDWP(Java Debug Wire Protocol)
  - 対象プログラムとデバッガのプロセス間で行われる通信プロトコル
- JDI(Java Debug Interface)
  - デバッグアプリケーションを容易に記述することができるインターフェース

JISDはこれらを用いることでブレークポイントの設定やステップ実行等，基本的なデバッグ操作を提供します．  
以下の各セクションでは，JPDAを用いた基本的なデバッグ操作について説明します．  

### 2.1 デバッガの起動と終了
JPDAを用いたデバッグでは，デバッガを起動すると, 内部で起動すべき対象プログラムがあるならばそれが起動されてから，デバッグイベント処理が開始されます．  

2.2以降で説明する`観測ポイントの設定`操作はデバッガ起動の前でも後でもよく，いずれの場合もデバッグ対象のクラスがロードされるまで設定が遅延されます．

たとえば，以下のようにDebuggerを生成したとします．


```java
var dbg = new Debugger("jisd.demo.HelloWorld", "-cp ../sample")
```

以下のコードによりデバッガを起動します．


```java
dbg.run(1000)
```

run()の引数には対象プログラムが観測ポイントに到達するまでの大まかな時間をミリ秒で指定します．上記の場合はデバッガ起動から1秒後にスレッドが再開されます．

また，デバッグを終了する場合は以下を実行します．


```java
dbg.exit()
```

デバッグを終了するとデバッグイベント処理が停止され，対象プログラムが終了します．

### 2.2 観測ポイントの設定
JISDのJPDAを用いたデバッグでは，2種類の観測ポイントを提供します．

- ブレークポイント
- ウォッチポイント  

**ブレークポイント**が設定された場合，その観測ポイントに到達した時点で対象プログラムを一時停止し，その場で変数の値の観測やステップ実行等を行うことができます．同時に，観測ポイントから観測可能な変数の情報(値含む)がDebugResultオブジェクトとして生成されます．  
一方，**ウォッチポイント**が設定された場合，その観測ポイントに到達した時点で対象プログラムを一時停止しますが観測ポイントから観測可能な変数の情報(値含む)の取得とDebugResultオブジェクトの生成後．**直ちに対象プログラムを再開させます**． 

どの変数に対してDebugResultオブジェクトを生成するかはユーザによる指定が可能です．

具体的な設定方法を以下で説明します．

### 2.3 行番号による設定

先ほど作成したDebuggerインスタンス`dbg`に対して`jisd.demo.HelloWorldクラス`の`28行目`に観測ポイントを設定したい場合は，
以下のいずれかのように設定することができます．

- ブレークポイントを設定したい場合


```java
Optional<Point> bp = dbg.stopAt("jisd.demo.HelloWorld", 28)
```

- ウォッチポイントを設定したい場合


```java
Optional<Point> wp = dbg.watch("jisd.demo.HelloWorld", 28) 
```

ブレークポイントもウォッチポイントもPointクラスを継承したBreakPointクラスのインスタンスとして扱われることに注意してください．また，ある行に重複して観測ポイントを設定することはできません．

一方，特定の変数のみに注目してDebugResultオブジェクトを生成したい場合があります．  
たとえば，`jisd.demo.HelloWorldクラス`の`28行目`の`変数a`に`ウォッチポイント`を設定したい場合は，


```java
String[] vars = {"a"};
dbg.watch("jisd.demo.HelloWorld", 28, vars);
```

のように設定します(ブレークポイントも同様)．

### 2.4 メソッド名による設定
行番号ではなくメソッドの先頭に観測ポイントを設定したい場合があります．   
たとえば，`jisd.demo.HelloWorldクラス`の`sayHello()`の先頭にブレークポイントを設定したい場合は，


```java
dbg.stopAt("jisd.demo.HelloWorld", "sayHello")
```

のように設定します(ウォッチポイントも同様)．

`jisd.demo.HelloWorldクラス`の`sayHello()`の先頭にブレークポイントを設定し，`変数a`と`変数b`を観測したい場合は，


```java
String[] vars = {"a", "b"};
dbg.stopAt("jisd.demo.HelloWorld", "sayHello", vars);
```

のように設定します(ウォッチポイントも同様)．

### 2.5 デフォルトクラス名
上記のいずれの場合も，クラス名を省略することができ，その場合デフォルトクラス名としてDebuggerの`main`フィールドが参照されます．
`main`フィールドは，Debuggerインスタンスの作成時の第一引数で指定したクラス名で初期化されます.これまでの例に登場した`dbg`では`"jisd.demo.HelloWorld"`がそれに該当します．

第一引数でクラス名を指定しない場合(portを指定した場合)は空のStringで初期化されます．Debugger生成後，setMain()メソッドで後から`main`フィールドを指定でき，デフォルトクラス名として利用できます．  
以下はデフォルトクラス名を"jisd.demo.HelloWorld"に設定した例です．


```java
dbg.setMain("jisd.demo.HelloWorld");
```

### 2.6 ブレーク時の操作
JISDは実行の再開，ステップ実行等のブレーク時特有の操作を提供します．ブレーク時以外に以下の操作を行った場合，その操作は無視されます．

#### 2.6.1 実行の再開


```java
dbg.cont()
```

#### 2.6.2 step into


```java
dbg.step()
// dbg.stepIn()
// dbg.stepInto()
```

#### 2.6.3 step over


```java
dbg.next()
// dbg.stepOver()
```

#### 2.6.4 step out


```java
dbg.finish()
// dbg.stepOut()
// dbg.stepReturn()
```

#### 2.6.5 ソースコード上の実行箇所の表示
設定されたsrcDirを走査して，現在のフレームに対応するソースコードを表示します．あらかじめ，走査対象のsrcDirを設定しておく必要があります．あるいはlist()の引数にsrcDirを逐次設定することも可能です．

```java
// dbg.setSrcDir("srcdir1", "srcdir2", ...)
dbg.list()
```

#### 2.6.6 観測可能な変数の一覧表示


```java
dbg.locals()
```

#### 2.6.7 スタックトレースの表示


```java
dbg.where()
```

### 2.7 遠隔デバッグ
JPDAを用いた遠隔デバッグは，`1. Debuggerインスタンスの作成`の項で説明したデバッグ方法のうち，`2.`に該当し，ユーザが手元でエージェントを付加して起動したプログラムに対してデバッグを行います．注意として，遠隔デバッグを行う際はデバッグ情報を付加してコンパイルするようにしてください．

以下はデバッグ対象のプログラムの実行例です．
```bash
java -agentlib:jdwp=transport=dt_socket,server=y,address=12345,suspend=n -cp bin jisd.demo.HelloWorld
```

これに対し，ユーザは`1.`の章の`デバッグ方法2.`で説明したようにDebuggerインスタンスを生成します．


```java
var dbg = new Debugger("host.docker.internal", 12345)
```

"host.docker.internal"はDocker Desktopで使用可能なdockerコンテナ上でのホストのアドレスで，これによりdockerコンテナ上に構築したJISDLab環境からホストで実行されているプログラムに接続することができます．

また，ホスト名を省略した場合，ホスト名に"localhost"が設定されます．


```java
var dbg = new Debugger(12345) // host = "localhost"
```

## 2.8 デバッガのリセット
デバッガのリセット時には`redef()`を使うと便利です．`redef()`はデバッガ自身のプロパティ情報をもとに新しいDebuggerを作成します．この際，ブレークポイントは引き継ぎません．

```java
var dbg2 = dbg.redef()
```

